## 0. 本章你要建立的“总框架”

- 这门课研究两件事：**数据怎么组织（数据结构）** + **怎么处理得更快更省（算法）**。
- 学习主线：
    1. 抽象问题 → 2) 选数据结构 → 3) 设计算法 → 4) 分析复杂度 → 5) 落地实现与验证
- 贯穿全书的核心指标：**时间复杂度**、**空间复杂度**、以及二者的折中。

---

## 1. 数据结构与算法的学习定位

### 1.1 为什么要学这门课（目的与作用）

- **计算机科学的“基础能力课”**：很多高级内容本质都落在“组织数据 + 高效计算”上。
- **工程实践的性能底座**：
    - 业务逻辑能跑只是第一步，数据量/并发上来后，瓶颈往往来自不合适的数据结构或低效算法。
    - 常见优化路径：先选对结构（如哈希表/堆/平衡树/图）再选对算法（如二分/贪心/DP/最短路）。
- **面试与竞赛高频考点**：考的是“抽象建模 + 复杂度思维 + 实现细节”。
- **和其他课程的关系（你可以这样理解）**
    - 程序设计语言：提供“表达与实现工具”（语法、类型、库）。
    - 数据结构与算法：提供“解题与性能方法论”（如何选结构、设计算法、证明/分析）。
    - 操作系统：关注“资源管理与并发”（调度、内存、文件系统）；背后也大量用到数据结构（队列、树、哈希）。
    - 组成原理：解释“为什么复杂度之外还有常数差异”（缓存、分支预测、存储层次）。

### 1.2 “程序 = 数据结构 + 算法”

> 一句话：**同一功能**，选不同的数据结构/算法，性能可能差几个数量级。

- 例：做“查找某个学号对应学生信息”
    - 用数组/顺序表存：只能顺序扫描 → `O(n)`
    - 用哈希表：平均 `O(1)`
    - 用有序数组 + 二分：`O(log n)`（但插入删除可能贵）
- 关系总结：
    - 数据结构决定“数据的组织与访问方式”
    - 算法决定“处理步骤与策略”
    - 二者相互制约：例如二分查找要求“有序 + 可随机访问”，不满足就用不了。

---

## 2. 基本概念与术语

### 2.1 数据、数据元素、数据项、数据对象、数据类型

- **数据（Data）**：客观事物的符号表示（数字、字符、记录、图像等）。
- **数据元素（Data Element）**：数据的基本单位，通常在结构中作为“结点/元素”出现。
    - 例：一个学生记录就是一个数据元素。
- **数据项（Data Item）**：数据元素的组成部分，是最小不可分的数据单位之一。
    - 例：学生记录中的 `学号/姓名/成绩` 各是数据项。
- **数据对象（Data Object）**：性质相同的数据元素集合。
    - 例：全校所有学生记录构成一个数据对象。
- **数据类型（Data Type）**：一组值的集合 + 在其上定义的一组操作（语言中的 `int/char` 或自定义 `struct/class` 都是类型的体现）。
    - 区分：数据类型更偏“语言层面的值与操作”，数据结构更偏“多元素组织 + 关系 + 操作”。

### 2.2 数据结构的三层含义（教材常见表述）

> **数据结构 = 逻辑结构 + 存储结构 + 运算（操作）及其实现**

1. **逻辑结构**：从“问题本身”看元素之间的关系（与内存如何存无关）
2. **存储结构/物理结构**：在计算机中“怎么放”（数组/指针/索引/哈希等）
3. **运算**：在结构上要做什么（查找、插入、删除、遍历、排序……）以及如何实现

---

## 3. 逻辑结构 vs 存储结构（一定要分清）

### 3.1 常见逻辑结构

- **集合结构**：元素同属一个集合，元素间关系弱/无显式关系。
- **线性结构**：一对一（除首尾外，每个元素有唯一前驱与后继）。
    - 典型：线性表、栈、队列、串
- **树形结构**：一对多（层次关系）。
    - 典型：二叉树、堆、B 树、目录树
- **图状结构**：多对多（任意结点可相连）。
    - 典型：社交网络、地图路径、依赖关系图

### 3.2 常见存储结构（物理结构）

- **顺序存储**：地址连续（典型：数组）。
    - 优：按下标随机访问快；实现简单
    - 缺：插入删除常需搬移元素；可能需要连续大块内存
- **链式存储**：用指针/引用链接（典型：链表、树的结点）。
    - 优：插入删除常只改指针；不要求连续
    - 缺：访问第 k 个要走 k 步；额外指针空间；缓存不友好
- **索引存储**：额外建立“索引表”（索引项指向数据位置）。
    - 用途：加速查找（比如块索引、数据库索引思想）
- **散列存储（哈希）**：用哈希函数把关键字映射到位置。
    - 优：平均查找快
    - 难点：冲突处理（链地址、开放定址等）

### 3.3 用一个例子把两者区分清楚：线性表

- **逻辑结构**：线性表（元素有先后次序）
- **存储结构可选**：
    - 顺序表（数组实现）：访问快，插删慢（中间位置）
    - 链表：插删快，按位置访问慢
- 结论：**同一逻辑结构可以有多种存储实现**；选择会影响操作复杂度。

---

## 4. 抽象数据类型（ADT）

### 4.1 ADT 的思想

> **ADT（Abstract Data Type）只关心“能做什么”，不关心“怎么做”。**

- 形式化描述通常包含：
    - **数据对象**（元素取值范围）
    - **数据关系**（元素间逻辑关系）
    - **基本操作**（接口/操作及其语义、前置条件、后置效果）

ADT 的价值：

- 把“接口/语义”与“具体实现（数组/链表/哈希等）”分离。
- 便于替换实现以优化性能，而不改上层使用方式。

### 4.2 ADT 示例：栈（Stack）

TEXT

复制

```text
1ADT Stack
2  Data:
3    有限序列 (a1, a2, ..., an)，满足后进先出 LIFO
4  Operations:
5    Init(S)        : 创建空栈
6    IsEmpty(S)     : 判断栈是否为空
7    Push(S, x)     : x 入栈，成为栈顶
8    Pop(S) -> x    : 删除栈顶元素并返回；若空则报错/返回失败
9    Top(S) -> x    : 返回栈顶元素但不删除；若空则报错/返回失败
10end ADT
11
```

- 实现可以是：
    - 顺序栈（数组 + top 指针）
    - 链栈（链表头作为栈顶）
- 注意：ADT 不规定用数组还是链表；只规定“操作语义”。

---

## 5. 算法的基本概念与特性

### 5.1 算法是什么

- **算法（Algorithm）**：为解决特定问题而规定的、**有限**且**确定**的操作步骤序列。
- 直观例子：在数组中找最大值
    - 扫一遍，维护当前最大值即可（线性扫描）。

### 5.2 算法的典型特性（五性）

- **有穷性**：必须在有限步内结束。
    - 反例：无条件死循环不是算法（不结束）。
- **确定性**：每一步含义明确，相同输入必得相同输出（或同样的行为规则）。
    - 反例：某一步“随机选一个数但不规定规则”会导致不确定。
- **可行性**：每一步都能通过基本操作在有限时间内完成。
- **输入**：0 个或多个输入（例如排序输入是待排序序列）。
- **输出**：至少 1 个输出（例如排序输出是有序序列）。

---

## 6. 算法设计目标与评价标准

### 6.1 正确性（第一位）

- 对所有**合法输入**都能给出正确结果。
- 常见理解层次（了解即可）：
    - “一般正确”：在典型/多数情况下正确
    - “边界正确”：对空、极值、重复、单元素等边界也正确
    - “完全正确”：对所有合法输入都正确（我们追求的目标）

### 6.2 可读性与可维护性

- 命名清晰、结构清楚、模块化、注释恰当。
- 课堂/面试写代码：可读性往往直接影响你能否“写对、写完、写稳”。

### 6.3 健壮性

- 面对非法输入、溢出风险、空指针、越界等情况能合理处理（报错/返回失败/保护性判断）。

### 6.4 高效率与低存储需求

- **时间效率**：尽量快（与时间复杂度相关）。
- **空间效率**：尽量省内存（与空间复杂度相关）。
- 常见现实取舍：用空间换时间（如哈希表、预处理前缀和），或用时间换空间（如原地算法）。

---

## 7. 时间复杂度与空间复杂度（大 O 入门）

### 7.1 两种效率度量方式

- **事后统计**：跑程序计时/计内存
    - 局限：依赖机器、编译器、输入数据、实现细节；难以比较“算法本身”。
- **事前分析**：用数学方法估计随 `n` 增长的趋势（本课主要方法）
    - 关注“数量级”，忽略常数与低阶项。

### 7.2 时间复杂度：大 O 的直观含义

> **时间复杂度**描述：当输入规模 `n` 增大时，算法基本操作次数的增长趋势，用 `O( )` 表示上界数量级。

- 常见复杂度（从快到慢，记住量级就行）：
    
    - `O(1)` 常数
    - `O(log n)` 对数（如二分查找）
    - `O(n)` 线性（如遍历找最大）
    - `O(n log n)`（如高效排序：归并/堆排序的量级）
    - `O(n^2)` 平方（如简单双重循环、冒泡/选择排序量级）
    - `O(2^n)`, `O(n!)` 指数/阶乘（通常很快不可用）
- 忽略常数与低次项示例：
    
    - `T(n) = 3n + 10` → `O(n)`
    - `T(n) = n^2 + 100n` → `O(n^2)`

### 7.3 用伪代码感受复杂度

- 单重循环 → `O(n)`

PSEUDO

复制

```pseudo
1sum = 0
2for i = 1..n:
3  sum += a[i]
4
```

- 双重循环 → `O(n^2)`

PSEUDO

复制

```pseudo
1cnt = 0
2for i = 1..n:
3  for j = 1..n:
4    cnt += 1
5
```

- 二分查找 → `O(log n)`（前提：有序 + 可随机访问）

PSEUDO

复制

```pseudo
1while l <= r:
2  mid = (l+r)/2
3  if a[mid] == x: return mid
4  else if a[mid] < x: l = mid+1
5  else: r = mid-1
6
```

### 7.4 空间复杂度

- **空间复杂度**：算法除输入数据外，额外占用空间随 `n` 的增长趋势。
- 例：
    - 需要额外数组 `b[1..n]`：`O(n)`
    - 递归可能有调用栈：深度 `d` → 额外 `O(d)`（例如递归遍历树）

### 7.5 时间 vs 空间（trade-off）

- 用空间换时间：哈希表、缓存、预处理（前缀和/倍增/稀疏表等思想）
- 用时间换空间：原地排序、重复计算避免存储

---

## 8. 问题—数据结构—算法：一条贯穿链

### 8.1 解决一个问题的一般步骤（建议背下来）

1. 明确问题：输入/输出/约束/边界情况
2. 抽象建模：数据对象是什么？关系是什么？操作是什么？
3. 选择数据结构：根据操作频率与约束选（查找多？插入多？是否有序？）
4. 设计算法：保证正确性，再考虑复杂度
5. 实现与测试：样例 + 边界 + 随机/对拍（如果会）
6. 分析与优化：瓶颈定位，必要时替换数据结构/算法

### 8.2 贯穿小例子：在线性表中查找元素

- 问题：给定表 `L` 和目标 `x`，返回位置/是否存在。
- 方案 A：顺序查找（无需有序）
    - 思路：从头扫到尾
    - 时间：`O(n)`；空间：`O(1)`
- 方案 B：折半查找（二分）（要求：有序 + 顺序存储/可随机访问）
    - 时间：`O(log n)`；空间：`O(1)`（迭代实现）
- 启示：
    - **同一问题**可有不同算法
    - 算法能否使用取决于数据结构/数据性质（“有序”“可随机访问”是条件）

---

## 9. 后续章节学习导引（你现在该期待什么）

### 9.1 主要章节与核心问题

- **线性表**：顺序表/链表；插删查的代价差异；迭代器/指针操作细节
- **栈与队列**：受限线性表；表达“后进先出/先进先出”；用于表达式求值、BFS、系统调用栈等
- **串、数组、广义表（视教材）**：模式匹配、存储方式、特殊结构表示
- **树与二叉树**：递归结构；遍历；二叉搜索树、堆、平衡树思想
- **图**：表示（邻接表/矩阵）；遍历（DFS/BFS）；最短路、最小生成树、拓扑排序等
- **查找**：从顺序查找→二分→哈希→平衡树/索引结构
- **排序**：比较排序与非比较排序；稳定性；时间/空间复杂度与适用场景

### 9.2 学习建议（实用）

- 多画图：链表指针变化、树/图遍历过程强烈建议手推一遍。
- 多写代码：每学一种结构至少写一版“可用实现”（含边界处理）。
- 多做对比：同一操作在不同结构上的复杂度对比，形成“选择直觉”。
- 习题策略：先做典型题（模板题）→ 再做变形题（条件变化、规模变化、约束变化）。

---

## 10. 快速自测（复习用）

1. 解释“逻辑结构”和“存储结构”的区别，并举一个同一逻辑结构的两种存储方式。
2. 为什么说“程序 = 数据结构 + 算法”？给一个具体例子说明差异。
3. 写出算法的五个特性，并举一个不满足有穷性的反例。
4. 二分查找为什么需要“有序”和“可随机访问”？缺一会怎样？
5. `3n+10` 和 `n^2+100n` 的大 O 分别是什么？为什么可以忽略常数与低阶项？